[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog",
    "section": "",
    "text": "Benchmarking Model Performance on Australian Electricity Demand Forecasting\n\n\n\n\n\n\ntime-series\n\n\nforecasting\n\n\n\n\n\n\n\n\n\nJan 20, 2025\n\n\nJeffrey Huang\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/2025-1-20/index.html",
    "href": "posts/2025-1-20/index.html",
    "title": "Benchmarking Model Performance on Australian Electricity Demand Forecasting",
    "section": "",
    "text": "Forecasting electricity demand is an extremely relevant problem for energy providers, as it influences not only the cost of day to day operations but also the timeliness and effectiveness of preparing for extreme weather conditions. Additionally, providers have to account for variations in geographic locations, further increasing the complexity of forecasting tasks.\nIn this blog post, I aim to explore the applications and performance of several forecasting methods for this task. I’m specifically using the Australian New South Wales Electricity Market dataset, which features the electricity price and demand of New South Wales and Victoria, as well as the amount transferred between the two states.\nThe data contains 45,312 instances for the days from May 7, 1996 to December 5, 1998, with observations recorded every half hour in each 24 hour period. I account for this granularity in my approach.\n\nelectricity.head()\n\n\n\n\n\n\n\n\ndate\nday\nperiod\nnswprice\nnswdemand\nvicprice\nvicdemand\ntransfer\nclass\n\n\n\n\n0\n0.0\n2\n0.000000\n0.056443\n0.439155\n0.003467\n0.422915\n0.414912\nUP\n\n\n1\n0.0\n2\n0.021277\n0.051699\n0.415055\n0.003467\n0.422915\n0.414912\nUP\n\n\n2\n0.0\n2\n0.042553\n0.051489\n0.385004\n0.003467\n0.422915\n0.414912\nUP\n\n\n3\n0.0\n2\n0.063830\n0.045485\n0.314639\n0.003467\n0.422915\n0.414912\nUP\n\n\n4\n0.0\n2\n0.085106\n0.042482\n0.251116\n0.003467\n0.422915\n0.414912\nDOWN\n\n\n\n\n\n\n\nThe data has a very fine level of granularity, making for a highly dense time series plot for the entire series. Right off the bat we can observe a longer term seasonality in the trend line of the graph.\n\nfig, ax = plot_series(electricity['nswdemand'])\nfig, ax = plot_series(electricity['nswprice'])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlotting a couple smaller length sections of the series (in intervals of 1000 observations) lets us see smaller scale seasonalities, which are immediately discernable.\n\nfig, ax = plot_series(electricity['nswdemand'][0:1000])\n\n\n\n\n\n\n\n\n\nfig, ax = plot_series(electricity['nswdemand'][20000:21000])\n\n\n\n\n\n\n\n\nThe magnitude of seasonal variations doesn’t appear to be influenced by the length of the time series, so I assume an additive decomposition to be the most appropriate such that\n\\(y_t = S_t + T_t + R_t\\)\nwhere data is decomposed into seasonal, trend, and remainder components respectively.\nThis data doesn’t contain any missing values:\n\n# Checking for missing values\nmissing_values = electricity.isna().sum()\nprint(missing_values)\n\ndate         0\nday          0\nperiod       0\nnswprice     0\nnswdemand    0\nvicprice     0\nvicdemand    0\ntransfer     0\nclass        0\ndtype: int64\n\n\nNow let’s perform an STL decomposition to get an idea of the seasonal and trend-cycle components of our data.\n\nstl = STLTransformer(return_components=True)\ny_stl = stl.fit_transform(electricity['nswdemand'])\nplot_series(y_stl['transformed'][0:1000])\nplot_series(y_stl['seasonal'][0:1000])\nplot_series(y_stl['trend'][0:1000])\nplot_series(y_stl['resid'][0:1000])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot_correlations(electricity['nswdemand'][0:1000])\n\n(&lt;Figure size 1200x800 with 3 Axes&gt;,\n array([&lt;Axes: ylabel='nswdemand'&gt;,\n        &lt;Axes: title={'center': 'Autocorrelation'}&gt;,\n        &lt;Axes: title={'center': 'Partial Autocorrelation'}&gt;], dtype=object))\n\n\n\n\n\n\n\n\n\nA closer look at the daily seasonality present in the data:\n\nplot_correlations(electricity['nswdemand'][0:96])\nplot_correlations(electricity['nswdemand'][0:48])\n\n(&lt;Figure size 1200x800 with 3 Axes&gt;,\n array([&lt;Axes: ylabel='nswdemand'&gt;,\n        &lt;Axes: title={'center': 'Autocorrelation'}&gt;,\n        &lt;Axes: title={'center': 'Partial Autocorrelation'}&gt;], dtype=object))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProphet is a model developed by Facebook for use in commercial forecasting applications; it has strong out of the box performance in data containing multiple seasonalities and holiday effects. I use a downgraded 1.1.5 version of Prophet due to optimization errors that arise with the 1.1.6 version.\nWhile the smallest level of granularity in some time series occurs through daily instances, this dataset has observations ever half-hour, meaning the period should be 48 for daily seasonality, 336 for weekly, and so on. We’ll have to add these as custom seasonalities to our Prophet model; this is accomplished by adding new custom seasonalities using the add_seasonality argument provided by the sktime wrapper.\nSince we’re using sktime, it has a slightly different way of handling add_seasonality() than in fbprophet; we have to add multiple custom seasonalities as a list of dictionaries to the constructor.\n\ny = electricity['nswdemand']\ny_train, y_test = temporal_train_test_split(y, test_size=0.2)\nforecaster = Prophet(\n    seasonality_mode='additive',\n    add_country_holidays={'country_name': 'Australia'},\n    yearly_seasonality=True,\n    weekly_seasonality=True,\n    daily_seasonality=True,\n    add_seasonality=[{\n        'name': 'daily-cycle',\n        'period': 48, # period of 48 representing observations per day\n        'fourier_order': 12\n    },\n    {\n        'name': 'weekly-cycle',\n        'period': 336, # period of 336 representing 7 day (weekly) cycle\n        'fourier_order': 3\n    },\n    {\n        'name': 'yearly-cycle',\n        'period': 17520,\n        'fourier_order': 10\n    }]\n)\nforecaster.fit(y_train)\n\n19:06:49 - cmdstanpy - INFO - Chain [1] start processing\n19:07:16 - cmdstanpy - INFO - Chain [1] done processing\n\n\nProphet(add_country_holidays={'country_name': 'Australia'},\n        add_seasonality=[{'fourier_order': 12, 'name': 'daily-cycle',\n                          'period': 48},\n                         {'fourier_order': 3, 'name': 'weekly-cycle',\n                          'period': 336},\n                         {'fourier_order': 10, 'name': 'yearly-cycle',\n                          'period': 17520}],\n        daily_seasonality=True, weekly_seasonality=True,\n        yearly_seasonality=True)Please rerun this cell to show the HTML repr or trust the notebook.Prophet?Documentation for ProphetProphet(add_country_holidays={'country_name': 'Australia'},\n        add_seasonality=[{'fourier_order': 12, 'name': 'daily-cycle',\n                          'period': 48},\n                         {'fourier_order': 3, 'name': 'weekly-cycle',\n                          'period': 336},\n                         {'fourier_order': 10, 'name': 'yearly-cycle',\n                          'period': 17520}],\n        daily_seasonality=True, weekly_seasonality=True,\n        yearly_seasonality=True)\n\n\nWe then evaluate model performance with mean average percentage error, mean absolute error, and mean squared error.\n\n# Specify forecasting horizon and pass on to forecasting algorithm\ny_pred = forecaster.predict(np.arange(len(y_test)))\nmape = mean_absolute_percentage_error(y_test, y_pred)\nmae = mean_absolute_error(y_test, y_pred)\nmse = mean_squared_error(y_test, y_pred)\nprint(f\"MAPE: {mape} \\nMAE: {mae} \\nMSE: {mse}\")\n\nMAPE: 0.15347452360520786 \nMAE: 0.060155303375532855 \nMSE: 0.006071706056646205\n\n\nLet’s visually see how our forecasts measure up to the actual values.\n\nfig, ax = plot_series(y_test, y_pred, labels=[\"y_test\", \"y_pred\"])\nfig, ax = plot_series(y_test[0:5000], y_pred[0:5000], labels=[\"y_test\", \"y_pred\"])\nfig, ax = plot_series(y_test[0:1000], y_pred[0:1000], labels=[\"y_test\", \"y_pred\"])\nfig, ax = plot_series(y_test[0:192], y_pred[0:192], labels=[\"y_test\", \"y_pred\"])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can plot the residuals to observe for any remaining seasonal patterns that weren’t captured by our model.\n\nfig, ax = plot_series(y_test[0:17520]-y_pred[0:17520])\nfig, ax = plot_series(y_test[0:1000]-y_pred[0:1000])\nfig, ax = plot_series(y_test[0:336]-y_pred[0:336])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAs can be seen, we’ve captured a good deal of the daily, weekly, and yearly seasonalities from the original data from our forecast. However, there remains additional patterns in the data that we haven’t accounted for. Specifically, it appears that during the first half of the year -in the summer months- the energy demand spikes much more frequently than in the latter half."
  }
]